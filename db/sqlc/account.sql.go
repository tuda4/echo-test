// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: account.sql

package db

import (
	"context"
	"time"
)

const changePassword = `-- name: ChangePassword :exec
UPDATE accounts SET hash_password = $2, updated_at = 'now()' WHERE uuid = $1 AND deleted_at IS NULL
`

type ChangePasswordParams struct {
	Uuid         string `db:"uuid"`
	HashPassword string `db:"hash_password"`
}

func (q *Queries) ChangePassword(ctx context.Context, arg ChangePasswordParams) error {
	_, err := q.db.ExecContext(ctx, changePassword, arg.Uuid, arg.HashPassword)
	return err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO  accounts (uuid, email, hash_password) VALUES ($1, $2, $3) RETURNING id, uuid, email, hash_password, created_at, updated_at, deleted_at
`

type CreateAccountParams struct {
	Uuid         string `db:"uuid"`
	Email        string `db:"email"`
	HashPassword string `db:"hash_password"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount, arg.Uuid, arg.Email, arg.HashPassword)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Email,
		&i.HashPassword,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOneAccount = `-- name: GetOneAccount :one
SELECT email, created_at, updated_at FROM accounts WHERE uuid = $1 AND  deleted_at IS NULL
`

type GetOneAccountRow struct {
	Email     string    `db:"email"`
	CreatedAt time.Time `db:"created_at"`
	UpdatedAt time.Time `db:"updated_at"`
}

func (q *Queries) GetOneAccount(ctx context.Context, uuid string) (GetOneAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getOneAccount, uuid)
	var i GetOneAccountRow
	err := row.Scan(&i.Email, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const listAccounts = `-- name: ListAccounts :many
SELECT email, created_at, updated_at FROM accounts WHERE email LIKE $1 AND deleted_at IS NULL ORDER BY created_at ASC OFFSET $2 LIMIT $3
`

type ListAccountsParams struct {
	Email  string `db:"email"`
	Offset int32  `db:"offset"`
	Limit  int32  `db:"limit"`
}

type ListAccountsRow struct {
	Email     string    `db:"email"`
	CreatedAt time.Time `db:"created_at"`
	UpdatedAt time.Time `db:"updated_at"`
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]ListAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccounts, arg.Email, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsRow
	for rows.Next() {
		var i ListAccountsRow
		if err := rows.Scan(&i.Email, &i.CreatedAt, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteAccount = `-- name: SoftDeleteAccount :exec
UPDATE accounts SET deleted_at = 'now()' WHERE uuid = $1
`

func (q *Queries) SoftDeleteAccount(ctx context.Context, uuid string) error {
	_, err := q.db.ExecContext(ctx, softDeleteAccount, uuid)
	return err
}
